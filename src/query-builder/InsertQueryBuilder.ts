import {QueryBuilder} from "./QueryBuilder";
import {ObjectLiteral} from "../common/ObjectLiteral";
import {ObjectType} from "../common/ObjectType";
import {QueryPartialEntity} from "./QueryPartialEntity";
import {SqlServerDriver} from "../driver/sqlserver/SqlServerDriver";
import {PostgresDriver} from "../driver/postgres/PostgresDriver";
import {SqliteDriver} from "../driver/sqlite/SqliteDriver";
import {MysqlDriver} from "../driver/mysql/MysqlDriver";
import {RandomGenerator} from "../util/RandomGenerator";
import {OrmUtils} from "../util/OrmUtils";
import {InsertResult} from "./result/InsertResult";
import {ReturningStatementNotSupportedError} from "../error/ReturningStatementNotSupportedError";
import {InsertValuesMissingError} from "../error/InsertValuesMissingError";
import {ColumnMetadata} from "../metadata/ColumnMetadata";

/**
 * Allows to build complex sql queries in a fashion way and execute those queries.
 */
export class InsertQueryBuilder<Entity> extends QueryBuilder<Entity> {

    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------

    /**
     * Gets generated sql query without parameters being replaced.
     */
    getQuery(): string {
        let sql = this.createInsertExpression();
        return sql.trim();
    }

    /**
     * Executes sql generated by query builder and returns raw database results.
     */
    async execute(): Promise<InsertResult> {
        const [sql, parameters] = this.getQueryAndParameters();
        const queryRunner = this.obtainQueryRunner();
        try {
            const insertResult = new InsertResult();
            insertResult.raw = await queryRunner.query(sql, parameters);
            if (this.expressionMap.mainAlias!.hasMetadata) {
                const metadata = this.expressionMap.mainAlias!.metadata;

                await Promise.all(this.getValueSets().map(async (valueSet, valueSetIndex) => {
                    const generatedMap = this.connection.driver.createGeneratedMap(metadata, insertResult.raw) || {};

                    metadata.generatedColumns.forEach(generatedColumn => {
                        if (generatedColumn.generationStrategy === "uuid") {
                            // uuid can be defined by user in a model, that's why first we get it
                            let uuid = generatedColumn.getEntityValue(valueSet);
                            if (!uuid) // if it was not defined by a user then InsertQueryBuilder generates it by its own, get this generated uuid value
                                uuid = this.expressionMap.parameters[generatedColumn.databaseName + valueSetIndex + "uuid"];

                            OrmUtils.mergeDeep(generatedMap, generatedColumn.createValueMap(uuid));
                        }
                    });

                    queryRunner.manager.merge(metadata.target, valueSet, generatedMap);
                    const identifier = metadata.getEntityIdMap(valueSet);

                    if (!identifier)
                        throw new Error(`Inserted entity identifier is empty, cannot finish insert operation execution.`);

                    // for postgres and mssql we use returning/output statement to get values of inserted default and generated values
                    // for other drivers we have to re-select this data from the database
                    const returningColumns = this.getEntityUpdationReturningColumns();
                    if (returningColumns.length && !this.isReturningSqlSupported()) {

                        // to select just inserted entity we need a criteria to select by.
                        // for newly inserted entities in drivers which do not support returning statement
                        // row identifier can only be an increment column
                        // (since its the only thing that can be generated by those databases)
                        // or (and) other primary key which is defined by a user and inserted value has it

                        const returningResult: any = await queryRunner.manager
                            .createQueryBuilder()
                            .select(metadata.primaryColumns.map(column => metadata.targetName + "." + column.propertyPath))
                            .addSelect(returningColumns.map(column => metadata.targetName + "." + column.propertyPath)) // todo: check why they aren't getting escaped
                            .from(metadata.target, metadata.targetName)
                            .where(identifier)
                            .getOne();

                        queryRunner.manager.merge(metadata.target, valueSet, returningResult);
                    }

                    insertResult.generatedMaps.push(generatedMap);
                    insertResult.identifiers.push(identifier);
                    insertResult.valueSets.push(valueSet);
                }));
            }

            return insertResult;

        } finally {
            if (queryRunner !== this.queryRunner) { // means we created our own query runner
                await queryRunner.release();
            }
        }
    }

    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------

    /**
     * Specifies INTO which entity's table insertion will be executed.
     */
    into<T>(entityTarget: ObjectType<T>|string, columns?: string[]): InsertQueryBuilder<T> {
        const mainAlias = this.createFromAlias(entityTarget);
        this.expressionMap.setMainAlias(mainAlias);
        this.expressionMap.insertColumns = columns || [];
        return (this as any) as InsertQueryBuilder<T>;
    }

    /**
     * Values needs to be inserted into table.
     */
    values(values: QueryPartialEntity<Entity>|QueryPartialEntity<Entity>[]): this {
        this.expressionMap.valuesSet = values;
        return this;
    }

    /**
     * Optional returning/output clause.
     * This will return given column values.
     */
    output(columns: string[]): this;

    /**
     * Optional returning/output clause.
     * Returning is a SQL string containing returning statement.
     */
    output(output: string): this;

    /**
     * Optional returning/output clause.
     */
    output(output: string|string[]): this;

    /**
     * Optional returning/output clause.
     */
    output(output: string|string[]): this {
        return this.returning(output);
    }

    /**
     * Optional returning/output clause.
     * This will return given column values.
     */
    returning(columns: string[]): this;

    /**
     * Optional returning/output clause.
     * Returning is a SQL string containing returning statement.
     */
    returning(returning: string): this;

    /**
     * Optional returning/output clause.
     */
    returning(returning: string|string[]): this;

    /**
     * Optional returning/output clause.
     */
    returning(returning: string|string[]): this {

        // not all databases support returning/output cause
        if (!this.isReturningSqlSupported())
            throw new ReturningStatementNotSupportedError();

        this.expressionMap.returning = returning;
        return this;
    }

    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------

    /**
     * Creates INSERT express used to perform insert query.
     */
    protected createInsertExpression() {

        const tableName = this.getTableName(this.getMainTableName());
        const returningExpression = this.createReturningExpression();
        const columnsExpression = this.createColumnNamesExpression();
        const valuesExpression = this.createValuesExpression();

        // generate INSERT query
        let query = `INSERT INTO ${tableName}`;

        // add columns expression
        if (columnsExpression) {
            query += `(${columnsExpression})`;
        } else {
            if (!valuesExpression && this.connection.driver instanceof MysqlDriver) // special syntax for mysql DEFAULT VALUES insertion
                query += "()";
        }

        // add OUTPUT expression
        if (returningExpression && this.connection.driver instanceof SqlServerDriver) {
            query += ` OUTPUT ${returningExpression}`;
        }

        // add VALUES expression
        if (valuesExpression) {
            query += ` VALUES ${valuesExpression}`;
        } else {
            if (this.connection.driver instanceof MysqlDriver) { // special syntax for mysql DEFAULT VALUES insertion
                query += " VALUES ()";
            } else {
                query += ` DEFAULT VALUES`;
            }
        }

        // add RETURNING expression
        if (returningExpression && this.connection.driver instanceof PostgresDriver) {
            query += ` RETURNING ${returningExpression}`;
        }

        return query;
    }

    /**
     * Gets list of columns where values must be inserted to.
     */
    protected getInsertedColumns(): ColumnMetadata[] {
        if (!this.expressionMap.mainAlias!.hasMetadata)
            return [];

        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {

            // if user specified list of columns he wants to insert to, then we filter only them
            if (this.expressionMap.insertColumns.length)
                return this.expressionMap.insertColumns.indexOf(column.propertyPath);

            // if user did not specified such list then return all columns except auto-increment one
            if (column.isGenerated && column.generationStrategy === "increment")
                return false;

            return true;
        });
    }

    /**
     * Creates a columns string where values must be inserted to for INSERT INTO expression.
     */
    protected createColumnNamesExpression(): string {
        const columns = this.getInsertedColumns();
        if (columns.length > 0)
            return columns.map(column => this.escape(column.databaseName)).join(", ");

        // get a table name and all column database names
        return this.expressionMap.insertColumns.map(columnName => this.escape(columnName)).join(", ");
    }

    /**
     * Creates list of values needs to be inserted in the VALUES expression.
     */
    protected createValuesExpression(): string {
        const valueSets = this.getValueSets();
        const columns = this.getInsertedColumns();

        if (this.expressionMap.mainAlias!.hasMetadata) {

            // get values needs to be inserted
            return valueSets.map((valueSet, insertionIndex) => {
                const columnValues = columns.map(column => {
                    const paramName = "_inserted_" + insertionIndex + "_" + column.databaseName;

                    let value = column.getEntityValue(valueSet);
                    if (column.referencedColumn && value instanceof Object) {
                        value = column.referencedColumn.getEntityValue(value);
                    }
                    value = this.connection.driver.preparePersistentValue(value, column);

                    if (column.isVersion) {
                        return "1";

                    } else if (column.isCreateDate || column.isUpdateDate) {
                        return "NOW()";

                    } else if (value === undefined && column.isGenerated && column.generationStrategy === "uuid") {
                        const paramName = column.databaseName + insertionIndex + "uuid";
                        this.setParameter(paramName, RandomGenerator.uuid4());
                        return ":" + paramName;

                    } else if (value === undefined) {
                        if (this.connection.driver instanceof SqliteDriver) {
                            return "NULL";

                        } else {
                            return "DEFAULT";
                        }

                    } else if (value instanceof Function) { // support for SQL expressions in update query
                        return value();

                    } else {
                        if (this.connection.driver instanceof SqlServerDriver) {
                            this.setParameter(paramName, this.connection.driver.parametrizeValue(column, value));
                        } else {
                            this.setParameter(paramName, value);
                        }
                        return ":" + paramName;
                    }
                }).join(", ").trim();
                return columnValues ? "(" + columnValues + ")" : "";
            }).join(", ");

        } else { // for tables without metadata

            // get values needs to be inserted
            return valueSets.map((valueSet, insertionIndex) => {
                const columnValues = Object.keys(valueSet).map(columnName => {
                    const paramName = "_inserted_" + insertionIndex + "_" + columnName;
                    const value = valueSet[columnName];

                    if (value instanceof Function) { // support for SQL expressions in update query
                        return value();

                    } else if (value === undefined) {
                        if (this.connection.driver instanceof SqliteDriver) {
                            return "NULL";

                        } else {
                            return "DEFAULT";
                        }

                    } else {
                        this.setParameter(paramName, value);
                        return ":" + paramName;
                    }
                }).join(", ").trim();
                return columnValues ? "(" + columnValues + ")" : "";
            }).join(", ");
        }
    }

    /**
     * Gets array of values need to be inserted into the target table.
     */
    protected getValueSets(): ObjectLiteral[] {
        if (this.expressionMap.valuesSet instanceof Array && this.expressionMap.valuesSet.length > 0)
            return this.expressionMap.valuesSet;

        if (this.expressionMap.valuesSet instanceof Object)
            return [this.expressionMap.valuesSet];

        throw new InsertValuesMissingError();
    }

}
